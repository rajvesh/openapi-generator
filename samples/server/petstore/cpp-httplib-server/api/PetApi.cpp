/*
 * Generated by OpenAPI Generator, do not edit
 * https://openapi-generator.tech
 */

#include "PetApi.h"

namespace api {

void Pet::registerRoutes(httplib::Server& svr) {
    svr.Post("/pet", [this](const httplib::Request& req, httplib::Response& res) {
        try {
                //request has schema in json, Hence parsing the request body to the model
                models::Pet request = models::Pet::fromJson(nlohmann::json::parse(req.body));
                auto result = handlePostForPet(request);

                std::visit([&](const auto& value) {
                            using T = std::decay_t<decltype(value)>;
                            if constexpr (std::is_same_v<T, models::Pet>) {
                                res.status = 200;
                                res.set_content(value.toJson(value).dump(), "application/json");
                            }
                        },
                        static_cast<const decltype(result)&>(result));
        } catch (const nlohmann::json::parse_error& e)
        {
            res.status = 400;
            nlohmann::json errorJson = {
                {"message", "Invalid JSON: " + std::string(e.what())}
            };
            res.set_content(errorJson.dump(), "application/json");
        } catch (const std::exception& e)
        {
            res.status = 500;
            nlohmann::json errorJson = {
                {"message", "Internal Server Error: " + std::string(e.what())}
            };
            res.set_content(errorJson.dump(), "application/json");
        }
    });

    svr.Delete("/pet/{petId}", [this](const httplib::Request& req, httplib::Response& res) {
                handleDeleteForPet{petId}();
    });

    svr.Get("/pet/findByStatus", [this](const httplib::Request& req, httplib::Response& res) {
        try {
                auto result = handleGetForPetFindByStatus();

                std::visit([&](const auto& value) {
                            using T = std::decay_t<decltype(value)>;
                            if constexpr (std::is_same_v<T, models::Pet>) {
                                res.status = 200;
                                res.set_content(value.toJson(value).dump(), "application/json");
                            }
                        },
                        static_cast<const decltype(result)&>(result));
        } catch (const nlohmann::json::parse_error& e)
        {
            res.status = 400;
            nlohmann::json errorJson = {
                {"message", "Invalid JSON: " + std::string(e.what())}
            };
            res.set_content(errorJson.dump(), "application/json");
        } catch (const std::exception& e)
        {
            res.status = 500;
            nlohmann::json errorJson = {
                {"message", "Internal Server Error: " + std::string(e.what())}
            };
            res.set_content(errorJson.dump(), "application/json");
        }
    });

    svr.Get("/pet/findByTags", [this](const httplib::Request& req, httplib::Response& res) {
        try {
                auto result = handleGetForPetFindByTags();

                std::visit([&](const auto& value) {
                            using T = std::decay_t<decltype(value)>;
                            if constexpr (std::is_same_v<T, models::Pet>) {
                                res.status = 200;
                                res.set_content(value.toJson(value).dump(), "application/json");
                            }
                        },
                        static_cast<const decltype(result)&>(result));
        } catch (const nlohmann::json::parse_error& e)
        {
            res.status = 400;
            nlohmann::json errorJson = {
                {"message", "Invalid JSON: " + std::string(e.what())}
            };
            res.set_content(errorJson.dump(), "application/json");
        } catch (const std::exception& e)
        {
            res.status = 500;
            nlohmann::json errorJson = {
                {"message", "Internal Server Error: " + std::string(e.what())}
            };
            res.set_content(errorJson.dump(), "application/json");
        }
    });

    svr.Get("/pet/{petId}", [this](const httplib::Request& req, httplib::Response& res) {
        try {
                auto result = handleGetForPet{petId}();

                std::visit([&](const auto& value) {
                            using T = std::decay_t<decltype(value)>;
                            if constexpr (std::is_same_v<T, models::Pet>) {
                                res.status = 200;
                                res.set_content(value.toJson(value).dump(), "application/json");
                            }
                        },
                        static_cast<const decltype(result)&>(result));
        } catch (const nlohmann::json::parse_error& e)
        {
            res.status = 400;
            nlohmann::json errorJson = {
                {"message", "Invalid JSON: " + std::string(e.what())}
            };
            res.set_content(errorJson.dump(), "application/json");
        } catch (const std::exception& e)
        {
            res.status = 500;
            nlohmann::json errorJson = {
                {"message", "Internal Server Error: " + std::string(e.what())}
            };
            res.set_content(errorJson.dump(), "application/json");
        }
    });

    svr.Put("/pet", [this](const httplib::Request& req, httplib::Response& res) {
        try {
                //request has schema in json, Hence parsing the request body to the model
                models::Pet request = models::Pet::fromJson(nlohmann::json::parse(req.body));
                auto result = handlePutForPet(request);

                std::visit([&](const auto& value) {
                            using T = std::decay_t<decltype(value)>;
                            if constexpr (std::is_same_v<T, models::Pet>) {
                                res.status = 200;
                                res.set_content(value.toJson(value).dump(), "application/json");
                            }
                        },
                        static_cast<const decltype(result)&>(result));
        } catch (const nlohmann::json::parse_error& e)
        {
            res.status = 400;
            nlohmann::json errorJson = {
                {"message", "Invalid JSON: " + std::string(e.what())}
            };
            res.set_content(errorJson.dump(), "application/json");
        } catch (const std::exception& e)
        {
            res.status = 500;
            nlohmann::json errorJson = {
                {"message", "Internal Server Error: " + std::string(e.what())}
            };
            res.set_content(errorJson.dump(), "application/json");
        }
    });

    svr.Post("/pet/{petId}", [this](const httplib::Request& req, httplib::Response& res) {
                handlePostForPet{petId}();
    });

    svr.Post("/pet/{petId}/uploadImage", [this](const httplib::Request& req, httplib::Response& res) {
        try {
                auto result = handlePostForPet{petId}UploadImage();

                std::visit([&](const auto& value) {
                            using T = std::decay_t<decltype(value)>;
                            if constexpr (std::is_same_v<T, models::ApiResponse>) {
                                res.status = 200;
                                res.set_content(value.toJson(value).dump(), "application/json");
                            }
                        },
                        static_cast<const decltype(result)&>(result));
        } catch (const nlohmann::json::parse_error& e)
        {
            res.status = 400;
            nlohmann::json errorJson = {
                {"message", "Invalid JSON: " + std::string(e.what())}
            };
            res.set_content(errorJson.dump(), "application/json");
        } catch (const std::exception& e)
        {
            res.status = 500;
            nlohmann::json errorJson = {
                {"message", "Internal Server Error: " + std::string(e.what())}
            };
            res.set_content(errorJson.dump(), "application/json");
        }
    });

}

} // namespace api