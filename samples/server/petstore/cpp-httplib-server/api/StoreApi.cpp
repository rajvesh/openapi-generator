/*
 * Generated by OpenAPI Generator, do not edit
 * https://openapi-generator.tech
 */

#include "StoreApi.h"

namespace api {

void Store::registerRoutes(httplib::Server& svr) {
    svr.Delete("/store/order/{orderId}", [this](const httplib::Request& req, httplib::Response& res) {
                handleDeleteForStoreOrder{orderId}();
    });

    svr.Get("/store/inventory", [this](const httplib::Request& req, httplib::Response& res) {
        try {
                auto result = handleGetForStoreInventory();

                std::visit([&](const auto& value) {
                            using T = std::decay_t<decltype(value)>;
                            if constexpr (std::is_same_v<T, int>) {
                                res.status = 200;
                                res.set_content(value.toJson(value).dump(), "application/json");
                            }
                        },
                        static_cast<const decltype(result)&>(result));
        } catch (const nlohmann::json::parse_error& e)
        {
            res.status = 400;
            nlohmann::json errorJson = {
                {"message", "Invalid JSON: " + std::string(e.what())}
            };
            res.set_content(errorJson.dump(), "application/json");
        } catch (const std::exception& e)
        {
            res.status = 500;
            nlohmann::json errorJson = {
                {"message", "Internal Server Error: " + std::string(e.what())}
            };
            res.set_content(errorJson.dump(), "application/json");
        }
    });

    svr.Get("/store/order/{orderId}", [this](const httplib::Request& req, httplib::Response& res) {
        try {
                auto result = handleGetForStoreOrder{orderId}();

                std::visit([&](const auto& value) {
                            using T = std::decay_t<decltype(value)>;
                            if constexpr (std::is_same_v<T, models::Order>) {
                                res.status = 200;
                                res.set_content(value.toJson(value).dump(), "application/json");
                            }
                        },
                        static_cast<const decltype(result)&>(result));
        } catch (const nlohmann::json::parse_error& e)
        {
            res.status = 400;
            nlohmann::json errorJson = {
                {"message", "Invalid JSON: " + std::string(e.what())}
            };
            res.set_content(errorJson.dump(), "application/json");
        } catch (const std::exception& e)
        {
            res.status = 500;
            nlohmann::json errorJson = {
                {"message", "Internal Server Error: " + std::string(e.what())}
            };
            res.set_content(errorJson.dump(), "application/json");
        }
    });

    svr.Post("/store/order", [this](const httplib::Request& req, httplib::Response& res) {
        try {
                //request has schema in json, Hence parsing the request body to the model
                models::Order request = models::Order::fromJson(nlohmann::json::parse(req.body));
                auto result = handlePostForStoreOrder(request);

                std::visit([&](const auto& value) {
                            using T = std::decay_t<decltype(value)>;
                            if constexpr (std::is_same_v<T, models::Order>) {
                                res.status = 200;
                                res.set_content(value.toJson(value).dump(), "application/json");
                            }
                        },
                        static_cast<const decltype(result)&>(result));
        } catch (const nlohmann::json::parse_error& e)
        {
            res.status = 400;
            nlohmann::json errorJson = {
                {"message", "Invalid JSON: " + std::string(e.what())}
            };
            res.set_content(errorJson.dump(), "application/json");
        } catch (const std::exception& e)
        {
            res.status = 500;
            nlohmann::json errorJson = {
                {"message", "Internal Server Error: " + std::string(e.what())}
            };
            res.set_content(errorJson.dump(), "application/json");
        }
    });

}

} // namespace api